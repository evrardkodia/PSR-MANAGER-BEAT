const express = require('express');
const path = require('path');
const fs = require('fs');
const fetch = require('node-fetch');
const { spawnSync } = require('child_process');
const { PrismaClient } = require('@prisma/client');

const router = express.Router();
const prisma = new PrismaClient();

console.log("üöÄ routes/player.js charg√©");

// Chemins
const TIMIDITY_EXE = 'timidity';
const TEMP_DIR = path.join(__dirname, '..', 'temp');
const UPLOAD_DIR = path.join(__dirname, '..', 'uploads');
const SCRIPTS_DIR = path.join(__dirname, '..', 'scripts');

// Utilise la variable d'environnement FFMPEG_PATH ou 'ffmpeg' par d√©faut
const FFMPEG_EXE = process.env.FFMPEG_PATH || 'ffmpeg';

const SF2_PATH = process.env.SF2_PATH || path.join(__dirname, '..', 'soundfonts', 'Yamaha_PSR.sf2');
const TIMIDITY_CFG_PATH = path.join(__dirname, '..', 'timidity.cfg');

if (!fs.existsSync(TEMP_DIR)) fs.mkdirSync(TEMP_DIR, { recursive: true });
if (!fs.existsSync(UPLOAD_DIR)) fs.mkdirSync(UPLOAD_DIR, { recursive: true });

// --- Utils ---
function publicBaseUrl(req) {
  const fromEnv = process.env.PUBLIC_URL;
  if (fromEnv) return fromEnv.replace(/\/$/, '');
  const proto = req.headers['x-forwarded-proto'] || req.protocol || 'https';
  const host = req.headers['x-forwarded-host'] || req.headers.host;
  return `${proto}://${host}`;
}

async function downloadStyFromUrl(url, destPath) {
  const response = await fetch(url);
  if (!response.ok) throw new Error(`Erreur t√©l√©chargement fichier .sty : ${response.status} ${response.statusText}`);
  const buffer = await response.buffer();
  fs.writeFileSync(destPath, buffer);
  console.log(`‚úÖ Fichier .sty t√©l√©charg√© : ${destPath}`);
}

function extractMidiFromSty(styPath, outputMidPath) {
  const data = fs.readFileSync(styPath);
  const headerIndex = data.indexOf(Buffer.from('MThd'));
  if (headerIndex === -1) throw new Error('Aucun header MIDI (MThd) trouv√© dans le fichier .sty');
  const midiData = data.slice(headerIndex);
  fs.writeFileSync(outputMidPath, midiData);
  console.log(`‚úÖ MIDI brut extrait : ${outputMidPath}`);
}

function extractMainWithPython(inputMidPath, outputMidPath, sectionName) {
  console.log(`üîß Extraction section "${sectionName}" via extract_main.py`);
  const pyScript = path.join(SCRIPTS_DIR, 'extract_main.py');
  const args = [pyScript, inputMidPath, outputMidPath, sectionName];
  const result = spawnSync('python3', args, { encoding: 'utf-8' });

  if (result.error) {
    console.error('‚ùå Erreur lors du spawn python:', result.error);
    throw result.error;
  }

  if (result.stdout?.trim()) {
    console.log('üêç extract_main.py stdout:', result.stdout.trim());
  }

  if (result.stderr?.trim()) {
    console.error('üêç extract_main.py stderr:', result.stderr.trim());
  }

  if (result.status !== 0) {
    throw new Error(`extract_main.py a √©chou√© avec le code ${result.status}`);
  }

  return result.stdout;
}


function convertMidToWav(midPath, wavPath) {
  console.log('üé∂ Conversion Timidity :', TIMIDITY_EXE, '-c', TIMIDITY_CFG_PATH, '-Ow', '--preserve-silence', '-A120', '-o', wavPath, midPath);
  const args = ['-c', TIMIDITY_CFG_PATH, '-Ow', '--preserve-silence', '-A120', '-o', wavPath, midPath];
  const convertProcess = spawnSync(TIMIDITY_EXE, args, { encoding: 'utf-8' });

  if (convertProcess.error) throw convertProcess.error;
  if (convertProcess.status !== 0) {
    console.error('‚ùå Timidity stderr:', convertProcess.stderr);
    throw new Error(`Timidity a √©chou√© avec le code ${convertProcess.status}`);
  }
  console.log('‚úÖ Conversion MIDI ‚Üí WAV termin√©e');
}

function trimWavFile(wavPath, duration) {
  const trimmedPath = wavPath.replace(/\.wav$/, '_trimmed.wav');
  const args = ['-i', wavPath, '-t', `${duration}`, '-c', 'copy', trimmedPath];
  const result = spawnSync(FFMPEG_EXE, args, { encoding: 'utf-8' });

  if (result.error || result.status !== 0) {
    console.error('‚ùå ffmpeg stderr:', result.stderr?.toString());
    console.error('‚ùå ffmpeg stdout:', result.stdout?.toString());
    if (result.error && result.error.code === 'ENOENT') {
      throw new Error('ffmpeg non trouv√© dans l‚Äôenvironnement. Assure-toi qu‚Äôil est bien install√© dans le Dockerfile.');
    }
    throw new Error('ffmpeg trim failed');
  }

  fs.renameSync(trimmedPath, wavPath);
  console.log('üî™ WAV rogn√© √†', duration, 'secondes');
}

// Routes

router.post('/prepare-main', async (req, res) => {
  console.log('‚û°Ô∏è POST /api/player/prepare-main appel√©e');
  const { beatId, mainLetter } = req.body;

  if (!beatId || !mainLetter) {
    return res.status(400).json({ error: 'beatId et mainLetter sont requis' });
  }

  try {
    const beat = await prisma.beat.findUnique({ where: { id: beatId } });
    if (!beat || !beat.url) {
      return res.status(404).json({ error: 'Beat ou URL introuvable' });
    }

    const inputStyPath = path.join(UPLOAD_DIR, beat.filename);
    await downloadStyFromUrl(beat.url, inputStyPath);

    const fullMidPath = path.join(TEMP_DIR, `${beatId}_full.mid`);
    extractMidiFromSty(inputStyPath, fullMidPath);

    const rawMidPath = path.join(TEMP_DIR, `${beatId}_main_${mainLetter}_raw.mid`);
    const sectionName = `Main ${mainLetter}`;
    const stdout = extractMainWithPython(fullMidPath, rawMidPath, sectionName);
    const duration = parseFloat(stdout.trim());

    if (!fs.existsSync(rawMidPath)) {
      return res.status(500).json({ error: 'Fichier MIDI extrait manquant apr√®s extraction' });
    }

    const wavPath = path.join(TEMP_DIR, `${beatId}_main_${mainLetter}.wav`);
    convertMidToWav(rawMidPath, wavPath);

    if (!fs.existsSync(wavPath)) {
      return res.status(500).json({ error: 'Fichier WAV manquant apr√®s conversion' });
    }

    if (!isNaN(duration)) {
      trimWavFile(wavPath, duration);
    }

    const wavUrl = `${publicBaseUrl(req)}/temp/${path.basename(wavPath)}`;
    console.log(`‚úÖ Pr√©paration termin√©e, wav accessible : ${wavUrl}`);

    return res.json({ wavUrl });
  } catch (err) {
    console.error('‚ùå Erreur serveur (prepare-main) :', err);
    return res.status(500).json({ error: 'Erreur serveur interne lors de la pr√©paration main' });
  }
});

// --- Log de la structure de sections ---

router.post('/prepare-all', async (req, res) => {
  console.log('‚û°Ô∏è POST /api/player/prepare-all appel√©e');
  const { beatId } = req.body;

  if (!beatId) {
    return res.status(400).json({ error: 'beatId est requis' });
  }

  try {
    // R√©cup√©rer beat dans la base
    const beat = await prisma.beat.findUnique({ where: { id: beatId } });
    if (!beat || !beat.url) {
      return res.status(404).json({ error: 'Beat ou URL introuvable' });
    }

    // T√©l√©chargement fichier .sty
    const inputStyPath = path.join(UPLOAD_DIR, beat.filename);
    await downloadStyFromUrl(beat.url, inputStyPath);

    // Extraction full MIDI
    const fullMidPath = path.join(TEMP_DIR, `${beatId}_full.mid`);
    extractMidiFromSty(inputStyPath, fullMidPath);

    // Lancer extract_sections.py pour lister sections
    const pyScript = path.join(SCRIPTS_DIR, 'extract_sections.py');
    const args = [pyScript, fullMidPath, TEMP_DIR];
    const result = spawnSync('python3', args, { encoding: 'utf-8' });

    if (result.error) throw result.error;
    if (result.stderr?.trim()) console.error('üêç extract_sections.py stderr:', result.stderr.trim());
    if (result.status !== 0) {
      throw new Error(`extract_sections.py a √©chou√© avec le code ${result.status}`);
    }

    console.log('üêç extract_sections.py stdout:', result.stdout.trim());
    const sectionsJson = JSON.parse(result.stdout.trim());
    const sections = sectionsJson.sections || {};

    // Helper : transforme "Main A" ‚Üí "main_a"
    function normalizeSectionName(name) {
      return name.toLowerCase().replace(/\s+/g, '_');
    }

    // Fonction pour g√©n√©rer un mid sectionn√© (synchrone)
    function generateMidSection(sectionName) {
      const outMid = path.join(TEMP_DIR, `${beatId}_${normalizeSectionName(sectionName)}.mid`);
      // La commande python avec option --section et --output (√† adapter si n√©cessaire)
      const cmd = `python3 ${pyScript} --input "${fullMidPath}" --section "${sectionName}" --output "${outMid}"`;
      const execResult = spawnSync(cmd, { shell: true, encoding: 'utf-8' });
      if (execResult.error || execResult.status !== 0) {
        console.warn(`‚ö†Ô∏è Erreur extraction MIDI section ${sectionName}:`, execResult.stderr || execResult.error);
        return null;
      }
      return outMid;
    }

    // Fonction conversion mid ‚Üí wav
    function convertMidToWav(midPath) {
      return new Promise((resolve, reject) => {
        const wavPath = midPath.replace(/\.mid$/i, '.wav');
        const cmd = `timidity "${midPath}" -Ow -o - | ffmpeg -y -i pipe: -ac 2 -ar 44100 "${wavPath}"`;
        exec(cmd, (error) => {
          if (error) {
            console.warn(`‚ö†Ô∏è Erreur conversion WAV pour ${midPath}:`, error);
            return reject(error);
          }
          resolve(wavPath);
        });
      });
    }

    // G√©n√©rer tous les mid et wav pour sections actives
    const generatedWavs = {};
    for (const [sectionName, isActive] of Object.entries(sections)) {
      if (isActive) {
        const midFile = generateMidSection(sectionName);
        if (midFile) {
          try {
            const wavFile = await convertMidToWav(midFile);
            // Stockage url relative pour frontend (adapter selon static server)
            generatedWavs[normalizeSectionName(sectionName)] = `/temp/${path.basename(wavFile)}`;
          } catch {
            // erreur d√©j√† logg√©e dans convertMidToWav
          }
        }
      }
    }

    // D√©terminer wavUrl par d√©faut = premier main_a, main_b, main_c, main_d dispo
    const mainsOrder = ['main_a', 'main_b', 'main_c', 'main_d'];
    let defaultWavUrl = null;
    for (const m of mainsOrder) {
      if (generatedWavs[m]) {
        defaultWavUrl = generatedWavs[m];
        break;
      }
    }

    // Formater la liste sections avec cl√©s normalis√©es (minuscules + underscore)
    const normalizedSections = {};
    for (const [key, val] of Object.entries(sections)) {
      normalizedSections[normalizeSectionName(key)] = val;
    }

    // Retourner la r√©ponse compl√®te
    return res.json({
      sections: normalizedSections,
      wavUrl: defaultWavUrl,
    });
  } catch (err) {
    console.error('‚ùå Erreur serveur (prepare-all) :', err);
    return res.status(500).json({ error: 'Erreur serveur interne lors de la pr√©paration des sections' });
  }
});



router.post('/play-section', (req, res) => {
  const { beatId, mainLetter } = req.body;
  if (!beatId || !mainLetter) {
    return res.status(400).json({ error: 'beatId et mainLetter sont requis' });
  }

  const fileName = `${beatId}_main_${mainLetter}.wav`;
  const fullPath = path.join(TEMP_DIR, fileName);

  console.log(`‚û°Ô∏è POST /api/player/play-section pour beatId=${beatId} main=${mainLetter}`);
  console.log(`üîé V√©rification existence: ${fullPath}`);

  if (!fs.existsSync(fullPath)) {
    console.error(`‚ùå Fichier introuvable: ${fullPath}`);
    return res.status(404).json({ error: 'Fichier WAV introuvable. R√©essayez de pr√©parer le main.' });
  }

  const base = publicBaseUrl(req);
  const wavUrl = `${base}/temp/${fileName}`;
  console.log(`‚úÖ WAV pr√™t: ${wavUrl}`);

  return res.json({ wavUrl, message: 'Lecture WAV confirm√©e c√¥t√© serveur' });
});

router.get('/stream', (req, res) => {
  const { beatId, mainLetter } = req.query;
  if (!beatId || !mainLetter) {
    return res.status(400).json({ error: 'beatId et mainLetter sont requis' });
  }
  const fileName = `${beatId}_main_${mainLetter}.wav`;
  const fullPath = path.join(TEMP_DIR, fileName);

  if (!fs.existsSync(fullPath)) {
    return res.status(404).json({ error: 'Fichier WAV introuvable.' });
  }

  res.setHeader('Content-Type', 'audio/wav');
  return res.sendFile(fullPath);
});

router.post('/cleanup', async (req, res) => {
  console.log("‚û°Ô∏è POST /api/player/cleanup appel√©e");
  const { beatId } = req.body;

  if (!beatId) return res.status(400).json({ error: 'beatId est requis' });

  const filesToDelete = fs.readdirSync(TEMP_DIR).filter(f => f.startsWith(String(beatId)));

  try {
    filesToDelete.forEach(file => {
      const p = path.join(TEMP_DIR, file);
      if (fs.existsSync(p)) fs.unlinkSync(p);
    });
    console.log(`üßπ Fichiers temporaires supprim√©s pour beatId=${beatId}`);
    res.status(200).json({ message: 'Fichiers supprim√©s' });
  } catch (err) {
    console.warn('‚ö†Ô∏è Probl√®me nettoyage :', err.message);
    res.status(500).json({ error: 'Erreur lors du nettoyage' });
  }
});

router.get('/temp', (req, res) => {
  console.log("‚û°Ô∏è GET /api/player/temp appel√©e");

  try {
    const files = fs.readdirSync(TEMP_DIR);
    const midiWavFiles = files.filter(file => file.endsWith('.mid') || file.endsWith('.wav'));

    console.log(`üìÇ Contenu de temp/ :\n${midiWavFiles.join('\n') || 'Aucun fichier .mid/.wav trouv√©'}`);

    res.json({
      count: midiWavFiles.length,
      files: midiWavFiles
    });
  } catch (err) {
    console.error('‚ùå Erreur lecture dossier temp :', err.message);
    res.status(500).json({ error: 'Erreur lecture du dossier temp' });
  }
});
module.exports = router;
